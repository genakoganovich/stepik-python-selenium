<html>
 <head></head>
 <body>
  <h2>Группировка тестов: setup&nbsp;</h2> 
  <p>А сейчас воспользуемся магией ООП уже для организации кода самих тест-кейсов. PyTest позволяет объединять несколько тест-кейсов в один класс.&nbsp;Зачем это делать и почему удобно?&nbsp;</p> 
  <p><strong>Во-первых,</strong> мы можем логически сгруппировать тесты в один класс просто ради более стройного кода: удобно, когда тесты, связанные с одним компонентом лежат в одном классе, а с помощью <strong>pytest.mark</strong> можно помечать сразу весь класс. Основное правило такое: название класса должно начинаться с <strong>Test</strong>, чтобы PyTest смог его обнаружить и запустить.</p> 
  <p>Давайте например объединим в группу два теста в файле <em>test_main_page.py</em> и пометим его меткой <strong>login_guest</strong>:</p> 
  <pre><code class="language-python">@pytest.mark.login_guest
class TestLoginFromMainPage():
    # не забываем передать первым аргументом self                       
    def test_guest_can_go_to_login_page(self, browser):     
         # реализация теста

    def test_guest_should_see_login_link(self, browser):
         # реализация теста</code></pre> 
  <p>Попробуйте запустить тесты в этом файле с меткой (нужно добавить "<strong>-m</strong> <strong>login_guest</strong>"). Вы увидите, что запустились оба теста, хотя метка всего одна.&nbsp;</p> 
  <p><strong>Во-вторых,</strong>&nbsp;для разных тест-кейсов можно выделять общие функции, чтобы не повторять код. Эти функции называются <strong>setup —</strong> функция,&nbsp;которая выполнится перед запуском каждого теста&nbsp;из класса, обычно туда входит подготовка данных, и <strong>teardown —</strong> функция, которая выполняется ПОСЛЕ каждого теста из класса, обычно там происходит удаление тех данных, которые мы создали во время теста. Хороший автотест должен сработать даже на чистой базе данных&nbsp;и удалить за собой сгенерированные в тесте данные. Такие функции&nbsp;реализуются с помощью фикстур, которые мы изучили в предыдущем модуле. Чтобы функция запускалась автоматически перед каждым тест-кейсом, нужно пометить её как <strong>@pytest.fixture</strong> с параметрами <strong>scope="function"</strong>,<strong>&nbsp;</strong>что значит запускать на каждую функцию, и&nbsp;<strong>autouse=True</strong>,<strong>&nbsp;</strong>что&nbsp;значит запускать автоматически&nbsp;без явного вызова фикстуры.</p> 
  <p>Мы уже немного говорили про независимость от контента в предыдущих шагах — идеальным решением было бы везде, где мы работаем со страницей продукта, создавать новый товар в нашем интернет-магазине перед тестом&nbsp;и удалять по завершении теста. К сожалению, наш интернет-магазин пока не имеет возможности создавать объекты по API,&nbsp;но в идеальном мире мы бы написали вот такой тест-класс в файле <em>test_product_page.py:</em></p> 
  <pre><code class="language-python">@pytest.mark.login
class TestLoginFromProductPage():
    @pytest.fixture(scope="function", autouse=True)
    def setup(self):
        self.product = ProductFactory(title = "Best book created by robot")
        # создаем по апи
        self.link = self.product.link
        yield
        # после этого ключевого слова начинается teardown
        # выполнится после каждого теста в классе
        # удаляем те данные, которые мы создали 
        self.product.delete()
        

    def test_guest_can_go_to_login_page_from_product_page(self, browser):
        page = ProductPage(browser, self.link)
        # дальше обычная реализация теста

    def test_guest_should_see_login_link(self, browser):
        page = ProductPage(browser, self.link)
        # дальше обычная реализация теста</code></pre> 
  <p>Работа с API&nbsp;выходит за рамки этого курса, но знание о том,&nbsp;что можно группировать тесты и выделять подготовительные шаги в единые для всех тестов функции — важно для каждого автоматизатора.</p>
 </body>
</html>