<html>
 <head></head>
 <body>
  <h2>Отрицательные проверки: как проверить отсутствие элемента</h2> 
  <p>Иногда в ходе написания авто-тестов возникает ситуация, когда нам нужно проверить не только присутствие элемента на странице, но и то, что элемента на странице нет. Здесь стоит разделять две принципиально разные ситуации, в зависимости от того как ведет себя веб-приложение:&nbsp;</p> 
  <p>&nbsp;<strong>1. Элемент потенциально может появится на странице</strong> (но вообще-то не должен). Например, мы&nbsp;открываем страницу товара, и ожидаем, что там нет сообщения об успешном добавлении в корзину. Мы проверяем, что элемента нет, но при позитивном сценарии, когда мы добавляем товар в корзину, сообщение тоже появляется не сразу. Если при негативной проверке мы не добавим ожидание, а сразу выдадим результат: <span style="color: #66cc66;">"True, элемента действительно нет, все хорошо"</span>, мы рискуем нарваться на ложно-зеленый тест. То есть, можем пропустить баг.&nbsp;</p> 
  <p><strong>2. Элемент присутствует на странице и должен исчезнуть</strong> со временем или в результате действий пользователя. Это может быть, например, удаление товара из корзины, или исчезновение лоадера с загрузкой.&nbsp;</p> 
  <h3>Почему нужно писать такие проверки с осторожностью?&nbsp;</h3> 
  <p><em>Во-первых</em>, нам приходится всегда гарантированно ждать. В первом примере&nbsp;нам всегда нужно ждать несколько секунд,&nbsp;чтобы убедиться, что элемент не появился. Если мы используем нашу написанную функцию is_element_present, то тест с такой проверкой будет ждать полные и честные 10 секунд:</p> 
  <pre><code>def should_not_be_success_message(self):
    assert not self.is_element_present(*ProductPageLocators.SUCCESS_MESSAGE),\
        "Success message is presented"</code></pre> 
  <p>Что очень много для зелёного теста. То есть implicit_wait уже в такой ситуации не подходит, придется использовать явное ожидание и аккуратно подбирать условия.&nbsp;Время ожидания тоже придется подбирать эмпирически, путем проб, ошибок, ложноположительных и ложноотрицательных результатов.&nbsp;</p> 
  <p><em>Во-вторых</em>, еще одна загвоздка с отрицательными проверками в том, что они могут давать ложноположительные срабатывания, если селектор устарел. Проверяем, что элемента с таким селектором нет,&nbsp;— проверка проходит, так как у элемента уже другой селектор. Элемент есть на экране&nbsp;— это&nbsp;баг, а тест зеленый. Это плохо!&nbsp;</p> 
  <p>Поэтому на каждый негативный тест обязательно должен приходиться положительный тест. В&nbsp;одном тесте проверяем, что элемента нет, в соседнем тесте, что элемент есть. Тогда мы сможем отслеживать актуальность селектора и не пропустим такой баг.&nbsp;</p> 
  <p>Дополнительная ссылка&nbsp;на пост Виталия Котова про распространенные грабли и отрицательные проверки, в том числе:</p> 
  <p>&nbsp;<a href="https://habr.com/ru/company/badoo/blog/419419/" rel="noopener noreferrer nofollow">UI-автотесты: как делать не стоит</a></p> 
  <h3>Как же тогда реализовывать такие проверки?&nbsp;</h3> 
  <p>Нужно ориентироваться на конкретную ситуацию, но общий совет — использовать явные ожидания и <a href="https://selenium-python.readthedocs.io/waits.html" rel="noopener noreferrer nofollow">Expected Conditions</a>, о которых мы говорили в предыдущих модулях.&nbsp;</p> 
  <p>Можно добавить в BasePage абстрактный метод, который проверяет, что элемент не появляется на странице в течение заданного времени:&nbsp;</p> 
  <pre><code>def is_not_element_present(self, how, what, timeout=4):
    try:
        WebDriverWait(self.browser, timeout).until(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return True

    return False</code></pre> 
  <p>Тогда его использование Page Object&nbsp;для&nbsp;страницы&nbsp;товара будет выглядеть так:&nbsp;</p> 
  <pre><code>def should_not_be_success_message(self):
    assert self.is_not_element_present(*ProductPageLocators.SUCCESS_MESSAGE), \
       "Success message is presented, but should not be"</code></pre> 
  <p>Если же мы хотим проверить, что какой-то элемент исчезает, то следует воспользоваться явным ожиданием вместе с функцией until_not, в зависимости от того, какой&nbsp;результат&nbsp;мы ожидаем:&nbsp;</p> 
  <pre><code>def is_disappeared(self, how, what, timeout=4):
    try:
        WebDriverWait(self.browser, timeout, 1, TimeoutException).\
            until_not(EC.presence_of_element_located((how, what)))
    except TimeoutException:
        return False

    return True</code></pre> 
  <p>Метод-проверка в классе про страницу товара будет выглядеть аналогично <strong>should_not_be_success_message</strong>, напишите его самостоятельно.</p> 
  <p>&nbsp;</p> 
  <p>Обратите внимание на разницу между методами&nbsp;<strong>is_not_element_present</strong> и <strong>is_disappeared</strong>.&nbsp;</p> 
  <p><strong>is_not_element_present</strong>: упадет, как только&nbsp;увидит искомый элемент. Не появился: успех, тест зеленый.&nbsp;</p> 
  <p><strong>is_disappeared</strong>: будет ждать до тех пор, пока элемент не исчезнет.&nbsp;</p> 
  <p>&nbsp;</p> 
  <p>Резюмируя, можно сказать, что разрабатывать такие проверки нужно очень аккуратно, использовать явные ожидания для&nbsp;сокращения&nbsp;времени прогона&nbsp;теста&nbsp;и всегда добавлять позитивную проверку на элемент в другом тесте.&nbsp;Без явной необходимости таких проверок лучше избегать.&nbsp;</p>
 </body>
</html>