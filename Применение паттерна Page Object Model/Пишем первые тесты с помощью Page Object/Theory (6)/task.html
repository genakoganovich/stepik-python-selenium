<html>
 <head></head>
 <body>
  <h2>Удобство поддержки тестов — инкапсуляция бизнес-логики в методах</h2> 
  <p>Что делать, если изменилась логика взаимодействия со страницей, которая используется у нас в нескольких тестах? Например, нам нужно проверить возможность перехода на страницу логина по ссылке в навбаре для каждой из страниц сайта. Предположим, что таких страниц 20, и, значит, у нас есть 20 тестов, использующих&nbsp;метод&nbsp;<strong>go_to_login_page</strong>&nbsp;класса MainPage. Затем разработчики&nbsp;добавили alert, который вызывается при клике на нужную нам ссылку. Мы увидим, что все 20 тестов упали, так как в методе go_to_login_page&nbsp;нет шага с обработкой alert, следовательно,&nbsp;метод should_be_login_page не сработает.&nbsp;Добавив обработку alert в метод <strong>go_to_login_page</strong>, мы восстановим работоспособность всех тестов, не меняя самих тестов:</p> 
  <pre><code class="language-python">def go_to_login_page(self):
&nbsp; &nbsp;link = self.browser.find_element_by_css_selector("#login_link")
   link.click()
   alert = self.browser.switch_to.alert
   alert.accept()</code></pre> 
  <p>Это еще одно преимущество&nbsp;использования паттерна Page Object&nbsp;— мы разделяем сам тест и логику взаимодействия со страницей. Тест становится более читабельным, и его легче поддерживать при изменениях в коде приложения.</p>
 </body>
</html>